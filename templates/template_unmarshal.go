package templates

// Complete template with all necessary functions
const UnmarshalTemplate = `// Code generated by bingen. DO NOT EDIT.

{{define "unmarshalScalarElement"}}
	
	{{if .IsCustomElementEncoder}}
		{{template "unmarshalElement" dict "Var" .Var "Shape" .}}
	{{ else if .IsSlice  }}
				// {{.Name}} ({{.BinaryTag}}) - slice
				// ElementType: {{.ElementType}}
				// Type: {{ .TypeName }}
				{{template "unmarshalSlice" . }}
	{{else if .IsBasicType}}
			  {{ unmarshalBasicTypeTemplate . }}
	{{else if .IsPointer}}
		// ElementType: {{.ElementType}}
		{{if .Element}}
		// Element: {{.Element.IsBasicType}}
		{{template "unmarshalScalarElement" dict
						"Var" (printf "s.%s" .FieldName)
						"FieldName" .FieldName
						"ElementType" .Element.ElementType
						"TypeName" .Element.TypeName
						"IsPointer" .Element.IsPointer
						"PointerDeref" .PointerDeref
						"PointerRef" .PointerRef
						"IsCustomElementEncoder" .Element.IsCustomElementEncoder
						"CustomElementEncoder" .Element.CustomElementEncoder
						"IsStruct" .Element.IsStruct
						"IsBasicType" .Element.IsBasicType
						"Element" .Element.Element
						"Field" .Element.Field
		}}
		{{else}}
	
			{{template "unmarshalScalarElement" dict
						"Var" (printf "s.%s" .FieldName)
						"FieldName" .FieldName
						"ElementType" .ElementType
						"TypeName" .TypeName
						"IsPointer" false
						"PointerDeref" .PointerDeref
						"PointerRef" .PointerRef
						"IsCustomElementEncoder" .IsCustomElementEncoder
						"CustomElementEncoder" .IsCustomElementEncoder
						"IsStruct" .IsStruct
						"IsBasicType" .IsBasicType
						"Element" .Element
						"Field" .Field
		}}
	{{end}}
	

	{{else if .IsStruct}}
				if offset+2 > len(data) {
						return fmt.Errorf("buffer too short for {{.Name}} length")
					}
					var itemData []byte
					itemData, offset, err = getBytes(data, offset)
					nestedData, err := {{.Var}}.UnmarshalBinary(itemData)
					if err != nil {
						return fmt.Errorf("failed to unmarshal {{.FieldName}}: %v", err)
					}
					 _m := (nestedData).({{ .TypeName}})
					 {{.Var}}  = {{.PointerRef}}_m


	{{else}}
			// {{.Var}} ({{.}}) - custom type
			{{if or .Element .HasElement }}
				// Element: {{.Element.ElementType}}
				{{template "unmarshalScalarElement" dict
								"Var" (printf "s.%s" .FieldName)
								"FieldName" .FieldName
								"ElementType" .Element.ElementType
								"TypeName" .Element.TypeName
								"IsPointer" .Element.IsPointer
								"PointerDeref" .Element.PointerDeref
								"PointerRef" .Element.PointerRef
								"IsCustomElementEncoder" .Element.IsCustomElementEncoder
								"CustomElementEncoder" .Element.CustomElementEncoder
								"IsStruct" .Element.IsStruct
								"IsBasicType" .Element.IsBasicType
								"Element" .Element.Element
								"Field" .Element.Field
				}}
			{{ else   }}
				// Element: No Element
				if offset+2 > len(data) {
						return fmt.Errorf("buffer too short for {{.Name}} length")
					}
						var itemData []byte
					itemData, offset, err = getBytes(data, offset)
					{{if .TypeName }}
					var _m  {{ .TypeName }}
					{{else}}
						var _m = any
					 	_m = 0
					 {{end}}
					err := unmarshalValue(itemData, &_m)
				
					if err != nil {
						return fmt.Errorf("failed to marshal custom type {{.Name}}: %v", err)
					}
						{{.Var}} = {{.PointerRef}}_m
				
					{{end}}
					
			
				{{end}}
	{{end}}


///////////////////////////////////
//////////////
{{define "unmarshalSlice"}}
{{if .IsCustomElementEncoder }}
	var itemData []byte
			itemData, offset, err = getBytes(data, offset)
			if _v, err := {{.CustomElementEncoder}}.UnmarshalBinary(itemData); err != nil {
				return fmt.Errorf("failed to unmarshal custom element encoder slice {{.Field.Name}}]: %v", err)
			} else {
				_m := (_v).({{ .TypeName }})
				s.{{.Field.Name}} = {{.PointerRef}}_m
			}

{{else if and .IsSlice (not .IsFixedArray) }}
	// Slice of {{.Field.Name}}: []{{.Field.Name}}
	if offset+2 > len(data) {
		return fmt.Errorf("buffer too short for {{.Field.Name}} length")
	}
	length := binary.LittleEndian.Uint16(data[offset : offset+2])
		offset += 2
		p := make({{.TypeName}}, length)
		for i := 0; i < int(length); i++ {
			{{template "unmarshalElement" dict "Var" "p[i]"  "Shape" .Element}}
		}
			
				s.{{.Field.Name}} =  {{.PointerRef}}p
		
	
{{else if .IsFixedArray}}
	var p = {{.TypeName}}
	length := {{.FixedArrayLength}}
	for i := 0; i < int(length); i++ {
		{{template "unmarshalElement" dict "Var" "p[i]" "Shape" .Element}}
	}
		_m := (*p).({{.TypeName}})
		s.{{.Field.Name}} =  {{.PointerRef}}_m
{{else if .IsPointer }}
	{{template "unmarshalSlice" .Element}}
{{else}}
	// Direct encoding
	d, _ := (s.{{.Field.Name}}).UnmarshalBinary()
	buf = appendBytes(buf, d)
{{end}}
{{end}}


{{define "unmarshalElement"}}
{{if .Shape }}
{{if .Shape.IsCustomElementEncoder}}
		
		
		if offset+2 > len(data) {
			return fmt.Errorf("buffer too short for {{.Var}} length")
		}
		var itemData []byte
		itemData, offset, err = getBytes(data, offset)
		
		if _v, err := {{.Shape.CustomElementEncoder}}.UnmarshalBinary(itemData); err != nil {
			return fmt.Errorf("failed to unmarshal custom element encoder slice {{.Var}}]: %v", err)
		} else {
		 	{{ if .Shape.TypeName}}
			_m := (_v).({{ .Shape.TypeName}})
			{{else}}
			_m := (_v)
			{{end}}
			{{.Var}} = {{.Shape.PointerRef}}_m
		}
{{else if and .Shape.IsSlice (not .Shape.IsFixedArray) }}
		// ElementIsSlice: {{ .Shape.IsSlice}}
		if offset+2 > len(data) {
		return fmt.Errorf("buffer too short for {{.Field.Name}} length")
	}
			length := binary.LittleEndian.Uint16(data[offset : offset+2])
			offset += 2
			{{.Var}} = make({{.Shape.TypeName}}, length)
				for i{{.Index}} := 0; i{{.Index}} < int(length); i{{.Index}}++ {
					{{template "unmarshalElement" dict "Var" (printf "%s[i%d]" .Var .Index) "Index" .Shape.Index  "Shape" .Shape.Element}}
				}
{{else if .Shape.IsFixedArray}}

			length := {{.Shape.FixedArrayLength}}
			{{.Var}} = {{.Shape.TypeName}}{}
			// {{.Element}} 
				for i{{.Index}} := 0; i{{.Index}} < int(length); i{{.Index}}++ {
					{{template "unmarshalElement" dict "Var"  (printf "%s[i%d]" .Var .Index)  "Index" .Shape.Index "Shape" .Shape.Element}}
				}
{{else}}
			// NONSLICE:
			// IsBasice {{ .Shape.IsBasicType}}
			// ElementType {{ .Shape.ElementType }}
			// Element {{ .Shape.Element }}
			// Element {{ .Shape.TypeName }}
					{{template "unmarshalScalarElement" dict
						"Var" .Var
						"FieldName" .Shape.Field.Name
						"TypeName" .Shape.TypeName
						"ElementType" .Shape.ElementType
						"IsPointer" .Shape.IsPointer
						"PointerDeref" .Shape.PointerDeref
						"PointerRef" .Shape.PointerRef
						"IsCustomElementEncoder" .Shape.IsCustomElementEncoder
						"CustomElementEncoder" .Shape.CustomElementEncoder
						"IsStruct" .Shape.IsStruct
						"IsBasicType" .Shape.IsBasicType
						"Element" .Shape.Element
						"Field" .Shape.Field
					}}
{{end}}
{{else }}
// No Shape
// Field: {{.Field.Name}}
// Var: {{.Var}}
// Element: {{.Element}}

{{end}}
{{end}}

`