package templates

// Complete template with all necessary functions
const HelperTemplate =  `// Code generated by bingen. DO NOT EDIT.

package {{.Package}}

import (
	"encoding/binary"
	"errors"
	"fmt"
	{{if .Options.UsePooling}}"sync"{{end}}
	{{if and .Options.ZeroCopy (not .Options.SafeMode)}}"unsafe"{{end}}
)

// Binary encoding constants
const (
	BinaryVersion = 1
	MaxStringLen = {{.Options.MaxStringLen}}
	MaxSliceLen  = {{.Options.MaxSliceLen}}
)

type BinaryMarshaler interface {
	MarshalBinary() ([]byte, error)
	BinarySize() (int, error)
}

type BinaryUnMarshaler interface {
	UnmarshalBinary(data []byte) error
}

type BinaryEncoder interface {
	Encode() ([]byte, error)
}



{{if .Options.UsePooling}}
// Buffer pool for encoding
var binaryBufPool = sync.Pool{
	New: func() interface{} {
		return make([]byte, 0, 8192)
	},
}
{{end}}

{{if and .Options.ZeroCopy (not .Options.SafeMode)}}
// bytesToStringUnsafe converts a byte slice to a string without copying
//go:nosplit
func bytesToStringUnsafe(b []byte) string {
	return *(*string)(unsafe.Pointer(&b))
}
{{end}}

// Helper functions for appending data
func appendUint16(buf []byte, v uint16) []byte {
	return append(buf, byte(v), byte(v>>8))
}

func appendUint32(buf []byte, v uint32) []byte {
	return append(buf, byte(v), byte(v>>8), byte(v>>16), byte(v>>24))
}

func appendUint64(buf []byte, v uint64) []byte {
	return append(buf,
		byte(v), byte(v>>8), byte(v>>16), byte(v>>24),
		byte(v>>32), byte(v>>40), byte(v>>48), byte(v>>56))
}

func appendBytes(buf, data []byte) []byte {
	buf = appendUint16(buf, uint16(len(data)))
	return append(buf, data...)
}

func getBytes(data []byte, offset int) ([]byte, int, error) {
	if offset+2 > len(data) {
		return nil, offset, errors.New("buffer too short for length")
	}
	length := binary.LittleEndian.Uint16(data[offset:offset+2])
	offset += 2
	if offset+int(length) > len(data) {
		return nil, offset, errors.New("buffer too short for data")
	}
	return data[offset:offset+int(length)], offset+int(length), nil
}

func getFixedBytes(data []byte, offset, length int) ([]byte, int, error) {
	if offset+length > len(data) {
		return nil, offset, errors.New("buffer too short for length")
	}
	
	
	return data[offset:offset+length], offset+int(length), nil
}

func marshalValue(v interface{}) ([]byte, error) {
	if be, ok := v.([]byte); ok {
			return be, nil
	}
	if be, ok := v.(string); ok {
			return []byte(be), nil
	}
	if bm, ok := v.(BinaryMarshaler); ok {
		return bm.MarshalBinary()
	}
	return nil, fmt.Errorf("unsupported type for marshaling: %T", v)
}

func unmarshalValue(data []byte, v interface{}) error {
	if be, ok := v.(*[]byte); ok {
		*be = data
		return nil
	}
	if be, ok := v.(*string); ok {
		*be = string(data)
		return nil
	}
	if bu, ok := v.(BinaryUnMarshaler); ok {
		return bu.UnmarshalBinary(data)
	}
	return fmt.Errorf("unsupported type for unmarshaling: %T", v)
}

func encodeValue(v interface{}) ([]byte, error) {
	if be, ok := v.([]byte); ok {
		return be, nil
	}
	if be, ok := v.(string); ok {
		return []byte(be), nil
	}
		
	if be, ok := v.(BinaryEncoder); ok {
		return be.Encode()
	}
	return nil, fmt.Errorf("unsupported type for encoding: %T", v)
}


func binarySize(v interface{}) (int, error) {
	if be, ok := v.([]byte); ok {
		return len(be), nil
	}
	if be, ok := v.(BinaryMarshaler); ok {
		return be.BinarySize()
	}
	return 0, fmt.Errorf("unsupported type for binary size: %T", v)
}

`