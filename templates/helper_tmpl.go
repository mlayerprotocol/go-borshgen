package templates

// Complete template with all necessary functions
const HelperTemplate =  `// Code generated by bingen. DO NOT EDIT.

package {{.Package}}

import (
	"encoding/binary"
	"errors"
	"fmt"
	"bytes"
	{{if .Options.UsePooling}}"sync"{{end}}
	{{if and .Options.ZeroCopy (not .Options.SafeMode)}}"unsafe"{{end}}
)

// Binary encoding constants
const (
	BinaryVersion = 1
	MaxStringLen = {{.Options.MaxStringLen}}
	MaxSliceLen  = {{.Options.MaxSliceLen}}
)

type EncodeField struct {
	Tag string
	EncodeType string
	Value any
}

{{if .Options.UsePooling}}
// Buffer pool for encoding

var binaryBufPoolXS = &sync.Pool{
	New: func() interface{} {
		return bytes.NewBuffer(make([]byte, 0, 1024))
	},
}

var binaryBufPoolMD = &sync.Pool{
	New: func() interface{} {
		return bytes.NewBuffer(make([]byte, 0, 2048))
	},
}

var binaryBufPoolLG = &sync.Pool{
	New: func() interface{} {
		return bytes.NewBuffer(make([]byte, 0, 8184))
	},
}
{{end}}

{{if and .Options.ZeroCopy (not .Options.SafeMode)}}
// bytesToStringUnsafe converts a byte slice to a string without copying
//go:nosplit
func bytesToStringUnsafe(b []byte) string {
	return *(*string)(unsafe.Pointer(&b))
}
{{end}}

// Helper functions for appending data to a bytes.Buffer
func appendUint16(buf *bytes.Buffer, v uint16) {
	buf.Write([]byte{byte(v), byte(v >> 8)})
}

func appendUint32(buf *bytes.Buffer, v uint32) {
	buf.Write([]byte{
		byte(v), byte(v >> 8), byte(v >> 16), byte(v >> 24),
	})
}

func appendUint64(buf *bytes.Buffer, v uint64) {
	buf.Write([]byte{
		byte(v), byte(v >> 8), byte(v >> 16), byte(v >> 24),
		byte(v >> 32), byte(v >> 40), byte(v >> 48), byte(v >> 56),
	})
}

func appendBytes(buf *bytes.Buffer, data []byte) {
	// Write length as uint16
	appendUint16(buf, uint16(len(data)))
	// Write data
	buf.Write(data)
}

func getBytes(data []byte, offset int) ([]byte, int, error) {
	if offset+2 > len(data) {
		return nil, offset, errors.New("buffer too short for length")
	}
	length := binary.LittleEndian.Uint16(data[offset : offset+2])
	offset += 2
	if offset+int(length) > len(data) {
		return nil, offset, errors.New("buffer too short for data")
	}
	return data[offset : offset+int(length)], offset + int(length), nil
}

func getFixedBytes(data []byte, offset, length int) ([]byte, int, error) {
	if offset+length > len(data) {
		return nil, offset, errors.New("buffer too short for length")
	}
	return data[offset : offset+length], offset + length, nil
}
func marshalValue(v interface{}) ([]byte, error) {
	if be, ok := v.([]byte); ok {
			return be, nil
	}
	if be, ok := v.(string); ok {
			return []byte(be), nil
	}
	if bm, ok := v.(BinaryMarshaler); ok {
		return bm.MarshalBorsh()
	}
	return nil, fmt.Errorf("unsupported type for marshaling: %T", v)
}

func unmarshalValue(data []byte, v interface{}) error {
	if be, ok := v.(*[]byte); ok {
		*be = data
		return nil
	}
	if be, ok := v.(*string); ok {
		*be = string(data)
		return nil
	}
	if bu, ok := v.(BinaryUnmarshaler); ok {
		return bu.UnmarshalBorsh(data)
	}
	return fmt.Errorf("unsupported type for unmarshaling: %T", v)
}

func encodeValue(v interface{}) ([]byte, error) {
	if be, ok := v.([]byte); ok {
		return be, nil
	}
	if be, ok := v.(string); ok {
		return []byte(be), nil
	}
		
	if be, ok := v.(BinaryEncoder); ok {
		return be.Encode()
	}
	return nil, fmt.Errorf("unsupported type for encoding: %T", v)
}


func binarySize(v interface{}) (int, error) {
	if be, ok := v.([]byte); ok {
		return len(be), nil
	}
	if be, ok := v.(BinaryMarshaler); ok {
		return be.BinarySize()
	}
	return 0, fmt.Errorf("unsupported type for binary size: %T", v)
}

`