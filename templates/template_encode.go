package templates

// Complete template with all necessary functions
const EncodeTemplate = `// Code generated by bingen. DO NOT EDIT.

{{define "encodeScalarElement"}}
	
	{{if .IsCustomElementEncoder}}
		data, err := {{.CustomElementEncoder}}.Encode(({{.PointerDeref}}{{.Var}}), s)
		if err != nil {
			return nil, fmt.Errorf("failed to encode {{.FieldName}}: %v", err)
		}
		buf = append(buf, data...)
	{{ else if .IsSlice  }}
				// {{.Name}} ({{.BinaryTag}}) - slice
				// ElementType: {{.ElementType}}
				// Type: {{ .TypeName }}
				{{template "encodeSlice" . }}
	
	{{else if .IsBasicType}}
					// BASICTYPE: {{ .IsBasicType }}
					// ELNTYPE: {{ .ElementType}}
					
					{{if eq .ElementType "string"}}
					str := {{.Var}}
					if len(str) > MaxStringLen {
						return nil, fmt.Errorf("{{.Field.Name}} too long: %d bytes", len(str))
					}
					buf = append(buf, []byte(str)...)

					{{else if eq .ElementType "[]byte"}}
					data := {{.Var}}
					if len(data) > MaxSliceLen {
						return nil, fmt.Errorf("{{.Field.Name}} too long: %d bytes", len(data))
					}
					buf = append(buf, data...)

					{{else if or (eq .ElementType "int64") (eq .ElementType "uint64") (eq .ElementType "int")}}
					buf = appendUint64(buf, uint64({{.PointerDeref}}{{.Var}}))

					{{else if or (eq .ElementType "int32") (eq .ElementType "uint32")}}
					buf = appendUint32(buf, uint32({{.PointerDeref}}{{.Var}}))

					{{else if or (eq .ElementType "int16") (eq .ElementType "uint16")}}
					buf = appendUint16(buf, uint16({{.PointerDeref}}{{.Var}}))

					{{else if or (eq .ElementType "int8") (eq .ElementType "uint8") (eq .ElementType "byte")}}
					buf = append(buf, byte({{.PointerDeref}}{{.Var}}))

					{{else if eq .ElementType "float32"}}
					buf = appendUint32(buf, math.Float32bits({{.PointerDeref}}{{.Var}}))

					{{else if eq .ElementType "float64"}}
					buf = appendUint64(buf, math.Float64bits({{.PointerDeref}}{{.Var}}))

					{{else if eq .ElementType "bool"}}
					if {{.PointerDeref}}{{.Var}} {
						buf = append(buf, 1)
					} else {
						buf = append(buf, 0)
					}
					{{end}}

	{{else if .IsStruct}}
					nestedData, err := {{.Var}}.Encode()
					if err != nil {
						return nil, fmt.Errorf("failed to encode {{.Field.Name}}: %v", err)
					}
					buf = append(buf, nestedData...)


	{{else}}
			// {{.Var}} ({{.}}) - custom type
			{{if or .Element .HasElement }}
				// Element: {{.Element.ElementType}}
				{{template "encodeScalarElement" dict
								"Var" (printf "s.%s" .FieldName)
								"FieldName" .Field.Name
								"TypeName" .Element.TypeName
								"PointerRef" .Element.PointerRef
								"ElementType" .Element.ElementType
								"IsPointer" .Element.IsPointer
								"PointerDeref" .Element.PointerDeref
								"IsCustomElementEncoder" .Element.IsCustomElementEncoder
								"CustomElementEncoder" .Element.CustomElementEncoder
								"IsStruct" .Element.IsStruct
								"IsBasicType" .Element.IsBasicType
								"Element" .Element.Element
								"Field" .Element.Field
				}}
			{{ else   }}
				// Element: No Element
					
					data, err := encodeValue({{.PointerDeref}}{{.Var}})
					if err != nil {
						return nil, fmt.Errorf("failed to encode custom type {{.Name}}: %v", err)
					}
					buf = append(buf, data...)
					{{end}}
					
			
				{{end}}
	{{end}}


///////////////////////////////////
//////////////
{{define "encodeSlice"}}
{{if .IsCustomElementEncoder }}
	data, err := {{.CustomElementEncoder}}.Encode(({{.PointerDeref}}s.{{.Field.Name}}), s)
		if err != nil {
			return nil, fmt.Errorf("failed to encode {{.Field.Name}}: %v", err)
		}
		buf = append(buf, data...)

{{else if and .IsSlice (not .IsFixedArray) }}
	// Slice of {{.Field.Name}}: []{{.Field.Name}}
		for _, item := range {{.PointerDeref}}(s.{{.Field.Name}}) {
			{{template "encodeElement" dict "Var" "item" "Shape" .Element}}
		}
{{else if .IsFixedArray}}
	// Fixed array of length {{.IsFixedArray}}: [{{.FixedArrayLength}}]{{.Field.Name}}
	for i := 0; i < {{.FixedArrayLength}}; i++ {
		{{template "encodeElement" dict "Var" (printf "s.%s[i]" .Field.Name) "Shape" .Element}}
	}
{{else if .IsPointer }}
	{{template "encodeSlice" .Element}}
{{else}}
	// Direct encoding
	d, _ := (s.{{.Field.Name}}).Encode()
	buf = append(buf, d...)
{{end}}
{{end}}


{{define "encodeElement"}}
{{if .Shape }}
{{if .Shape.IsCustomElementEncoder}}
		data, err := {{.Shape.CustomElementEncoder}}.Encode(({{.Shape.PointerDeref}}{{.Var}}), s)
		if err != nil {
			return nil, fmt.Errorf("failed to encode {{.Shape.Field.Name}}: %v", err)
		}
		buf = append(buf, data...)
{{else if .Shape.IsSlice}}
		// ElementIsSlice: {{ .Shape.IsSlice}}
		for _, inner := range {{.Shape.PointerDeref}}({{.Var}}) {
			{{template "encodeElement" dict "Var" "inner" "Shape" .Shape.Element}}
		}
{{else if .Shape.IsFixedArray}}
	for j := 0; j < {{.Shape.FixedArrayLength}}; j++ {
		{{template "encodeElement" dict "Var" (printf "%s[j]" .Var) "Shape" .Shape.Element}}
	}
{{else}}
			// NONSLICE:
			// IsBasice {{ .Shape.IsBasicType}}
			// ElementType {{ .Shape.ElementType }}
			// Element {{ .Shape.Element }}
					{{template "encodeScalarElement" dict
						"Var" .Var
						"FieldName" .Shape.Field.Name
						"TypeName" .Shape.TypeName
						"PointerRef" .Shape.PointerRef
						"ElementType" .Shape.ElementType
						"IsPointer" .Shape.IsPointer
						"PointerDeref" .Shape.PointerDeref
						"IsCustomElementEncoder" .Shape.IsCustomElementEncoder
						"CustomElementEncoder" .Shape.CustomElementEncoder
						"IsStruct" .Shape.IsStruct
						"IsBasicType" .Shape.IsBasicType
						"Element" .Shape.Element
						"Field" .Shape.Field
					}}
{{end}}
{{else }}
// No Shape
// Field: {{.Field.Name}}
// Var: {{.Var}}
// Element: {{.Element}}
 		data, err := encodeValue({{.Var}})
		if err != nil {
			return nil, fmt.Errorf("failed to encode {{.FieldName}}: %v", err)
		}
		buf = append(buf, data...)
{{end}}
{{end}}

`