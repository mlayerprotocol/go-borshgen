package templates

// Complete template with all necessary functions
const MarshalBorshTemplate = `// Code generated by bingen. DO NOT EDIT.



// MarshalBorsh marshals {{.Name}} to binary format
{{define "marshalBinary"}}
func (s {{.Name}}) MarshalBorsh() ([]byte, error) {
	size, err := s.BinarySize()
	if err != nil {
		return nil, err
	}

	{{if .Options.UsePooling}}
	var pool *sync.Pool
	if size > 512 { // Adjusted threshold based on typical message size
		pool = binaryBufPoolLG
	} else {
		pool = binaryBufPoolMD
	}
	buf := pool.Get().(*bytes.Buffer) // Use *bytes.Buffer for Borsh
	defer pool.Put(buf)
	buf.Reset() // Reset length and contents
	if cap(buf.Bytes()) < size {
		buf.Grow(size) // Ensure sufficient capacity
	}
{{else}}
	buf := bytes.NewBuffer(make([]byte, 0, size))
{{end}}
	{{range .Fields}}
		{{if not .ShouldIgnore}}
		
		

		{{if or .IsPointer .IsPointerSlice}}
		{
			if s.{{.Name}} == nil {
				buf.WriteByte(0) // // nil marker
				goto SKIP{{.Name}}
			} else {
				buf.WriteByte(1) // non-nil marker
			}
		}
		{{end}}
		{

		{{if .IsCustomFieldEncoder}}
			data, err := {{.CustomFieldEncoder}}.MarshalBorsh(({{.PointerDeref}}(s.{{.Name}})), s)
			if err != nil {
				return nil, fmt.Errorf("failed to marshal {{.Name}}: %v", err)
			}
			appendBytes(buf, data)
		{{else if .IsCustomElementEncoder}}
			data, err := {{.CustomElementEncoder}}.MarshalBorsh(({{.PointerDeref}}(s.{{.Name}})), s)
			if err != nil {
				return nil, fmt.Errorf("failed to marshal {{.Name}}: %v", err)
			}
			appendBytes(buf, data)
		{{ else if or .IsSlice  .Element.IsSlice  }}
				// {{.Name}} ({{.BinaryTag}}) - slice
				// ElementType: {{.Element.TypeName}}
				// Type: {{ .Element.TypeName }}
				// CustomType: {{ .Element.CustomTypeName }}
				// IsCustomEncoder: {{ .IsCustomElementEncoder }}

				
				{{template "marshalSlice"  .Element }}

		{{ else if or .IsPointer .IsPointerSlice }}
					// {{.Name}} ({{.BinaryTag}}) - Pointer
					// ElementType: {{.Element.ElementType}}
					// Type: {{ .Element.TypeName }}
					// ActualType: {{ .ActualType }}
					// BasicType: {{ .Element.IsBasicType }}
			
					// ElementType: {{ .Element.TypeName }}


					{{template "marshalScalarElement"  dict
					"Var" (printf "s.%s" .Name)
					"FieldName" .Name
					"TypeName" .Element.TypeName
					"ElementType" .Element.ElementType
					"IsPointer" .Element.IsPointer
					"PointerDeref" .Element.PointerDeref
					"PointerRef" .Element.PointerRef
					"IsCustomElementEncoder" .Element.IsCustomElementEncoder
					"CustomElementEncoder" .Element.CustomElementEncoder
					"IsStruct" .Element.IsStruct
					"IsBasicType" .Element.IsBasicType
					"Element" .Element.Element
					"Field" .
					}}
			
	
		{{else}}
		// IsCustomElementEncoder: {{.IsCustomElementEncoder}}
		// IsCustomElementEncoder: {{.Element.IsCustomElementEncoder}}
					{{template "marshalScalarElement" dict
					"Var" (printf "s.%s" .Name)
					"FieldName" .Name
					"ElementType" .ElementType
					"TypeName" .TypeName
					"IsSlice" .IsSlice
					"IsPointer" .IsPointer
					"PointerDeref" .PointerDeref
					"PointerRef" .PointerRef
					"IsCustomElementEncoder" .IsCustomElementEncoder
					"CustomElementEncoder" .CustomElementEncoder
					"IsStruct" .IsStruct
					"IsBasicType" .IsBasicType
					"Element" .Element
					"Field" .Field
				}}
			{{end}}
				
			
		}
			{{if .IsPointer}}
					SKIP{{.Name}}:
				{{end}}
		{{end}}
	{{end}}

	
		// Copy result before returning buffer to pool
		result := make([]byte, buf.Len())
		copy(result, buf.Bytes())
		return result, nil
		
	
}
{{end}}
`