package templates

// Complete template with all necessary functions
const MainTemplate = `// Code generated by bingen. DO NOT EDIT.

package {{.Package}}

import (
	"encoding/binary"
	"encoding/json"
	"errors"
	"fmt"
	"math"
	{{if and .Options.ZeroCopy (not .Options.SafeMode)}}"unsafe"{{end}}
	{{ range .Packages }}"{{ .Package }}"
	{{end}}
)
{{ range .Packages }}var _ {{ .CustomType }}
{{end}}
var _ = fmt.Print
var _ = errors.New("")
var _ = binary.MaxVarintLen16
var _  json.RawMessage
var _  =  math.Pi
var _ = fmt.Print
{{range .Structs}}
{{$options := .Options}}
{{$structName := .Name}}

{{if $options.ZeroCopy}}
// ZeroCopyView provides zero-copy access to {{.Name}} data
type {{.Name}}View struct {
	data   []byte
	offset int
}

// New{{.Name}}View creates a zero-copy view of {{.Name}} from binary data
func New{{.Name}}View(data []byte) (*{{.Name}}View, error) {
	if len(data) < 4 {
		return nil, errors.New("data too short for header")
	}
	return &{{.Name}}View{data: data, offset: 0}, nil
}

{{range .Fields}}
{{if and (not .ShouldIgnore) .CanZeroCopy}}
{{if eq .Type "string"}}
// {{.Name}} returns the {{.BinaryTag}} field as a zero-copy string
func (v *{{$structName}}View) {{.Name}}() (string, error) {
	offset := v.calculateFieldOffset("{{.Name}}")
	if offset < 0 {
		return "", fmt.Errorf("cannot calculate offset for {{.Name}}")
	}
	if offset+2 > len(v.data) {
		return "", fmt.Errorf("buffer too short for {{.Name}} length")
	}
	length := binary.LittleEndian.Uint16(v.data[offset:offset+2])
	if offset+2+int(length) > len(v.data) {
		return "", fmt.Errorf("buffer too short for {{.Name}} data")
	}
	{{if $options.SafeMode}}
	return string(v.data[offset+2:offset+2+int(length)]), nil
	{{else}}
	return bytesToStringUnsafe(v.data[offset+2:offset+2+int(length)]), nil
	{{end}}
}
{{else if eq .Type "[]byte"}}
// {{.Name}} returns the {{.BinaryTag}} field as a zero-copy byte slice
func (v *{{$structName}}View) {{.Name}}() ([]byte, error) {
	offset := v.calculateFieldOffset("{{.Name}}")
	if offset < 0 {
		return nil, fmt.Errorf("cannot calculate offset for {{.Name}}")
	}
	if offset+2 > len(v.data) {
		return nil, fmt.Errorf("buffer too short for {{.Name}} length")
	}
	length := binary.LittleEndian.Uint16(v.data[offset:offset+2])
	if offset+2+int(length) > len(v.data) {
		return nil, fmt.Errorf("buffer too short for {{.Name}} data")
	}
	return v.data[offset+2:offset+2+int(length)], nil
}
{{else if eq .Type "uint64"}}
// {{.Name}} returns the {{.BinaryTag}} field
func (v *{{$structName}}View) {{.Name}}() (uint64, error) {
	offset := v.calculateFieldOffset("{{.Name}}")
	if offset < 0 {
		return 0, fmt.Errorf("cannot calculate offset for {{.Name}}")
	}
	if offset+8 > len(v.data) {
		return 0, fmt.Errorf("buffer too short for {{.Name}}")
	}
	return binary.LittleEndian.Uint64(v.data[offset:]), nil
}
{{else if eq .Type "uint32"}}
// {{.Name}} returns the {{.BinaryTag}} field
func (v *{{$structName}}View) {{.Name}}() (uint32, error) {
	offset := v.calculateFieldOffset("{{.Name}}")
	if offset < 0 {
		return 0, fmt.Errorf("cannot calculate offset for {{.Name}}")
	}
	if offset+4 > len(v.data) {
		return 0, fmt.Errorf("buffer too short for {{.Name}}")
	}
	return binary.LittleEndian.Uint32(v.data[offset:]), nil
}
{{else if eq .Type "int64"}}
// {{.Name}} returns the {{.BinaryTag}} field
func (v *{{$structName}}View) {{.Name}}() (int64, error) {
	offset := v.calculateFieldOffset("{{.Name}}")
	if offset < 0 {
		return 0, fmt.Errorf("cannot calculate offset for {{.Name}}")
	}
	if offset+8 > len(v.data) {
		return 0, fmt.Errorf("buffer too short for {{.Name}}")
	}
	return int64(binary.LittleEndian.Uint64(v.data[offset:])), nil
}
{{else if eq .Type "int32"}}
// {{.Name}} returns the {{.BinaryTag}} field
func (v *{{$structName}}View) {{.Name}}() (int32, error) {
	offset := v.calculateFieldOffset("{{.Name}}")
	if offset < 0 {
		return 0, fmt.Errorf("cannot calculate offset for {{.Name}}")
	}
	if offset+4 > len(v.data) {
		return 0, fmt.Errorf("buffer too short for {{.Name}}")
	}
	return int32(binary.LittleEndian.Uint32(v.data[offset:])), nil
}
{{else if eq .Type "int"}}
// {{.Name}} returns the {{.BinaryTag}} field
func (v *{{$structName}}View) {{.Name}}() (int, error) {
	offset := v.calculateFieldOffset("{{.Name}}")
	if offset < 0 {
		return 0, fmt.Errorf("cannot calculate offset for {{.Name}}")
	}
	if offset+4 > len(v.data) {
		return 0, fmt.Errorf("buffer too short for {{.Name}}")
	}
	return int(binary.LittleEndian.Uint32(v.data[offset:])), nil
}
{{else if eq .Type "float32"}}
// {{.Name}} returns the {{.BinaryTag}} field
func (v *{{$structName}}View) {{.Name}}() (float32, error) {
	offset := v.calculateFieldOffset("{{.Name}}")
	if offset < 0 {
		return 0, fmt.Errorf("cannot calculate offset for {{.Name}}")
	}
	if offset+4 > len(v.data) {
		return 0, fmt.Errorf("buffer too short for {{.Name}}")
	}
	return math.Float32frombits(binary.LittleEndian.Uint32(v.data[offset:])), nil
}
{{else if eq .Type "float64"}}
// {{.Name}} returns the {{.BinaryTag}} field
func (v *{{$structName}}View) {{.Name}}() (float64, error) {
	offset := v.calculateFieldOffset("{{.Name}}")
	if offset < 0 {
		return 0, fmt.Errorf("cannot calculate offset for {{.Name}}")
	}
	if offset+8 > len(v.data) {
		return 0, fmt.Errorf("buffer too short for {{.Name}}")
	}
	return math.Float64frombits(binary.LittleEndian.Uint64(v.data[offset:])), nil
}
{{else if eq .Type "bool"}}
// {{.Name}} returns the {{.BinaryTag}} field
func (v *{{$structName}}View) {{.Name}}() (bool, error) {
	offset := v.calculateFieldOffset("{{.Name}}")
	if offset < 0 {
		return false, fmt.Errorf("cannot calculate offset for {{.Name}}")
	}
	if offset >= len(v.data) {
		return false, fmt.Errorf("buffer too short for {{.Name}}")
	}
	return v.data[offset] != 0, nil
}
{{end}}
{{end}}
{{end}}


// calculateFieldOffset calculates the byte offset for a specific field
func (v *{{.Name}}View) calculateFieldOffset(fieldName string) int {
	offset := 0
	length := uint16(0)
	_ = length
	{{range .Fields}}
		{{if not .ShouldIgnore}}
			if fieldName == "{{.Name}}" {
				return offset
			}
			// Skip {{.Name}} field
			{{if eq .Type "string"}}
				if offset+2 > len(v.data) {
					return -1
				}
				length = binary.LittleEndian.Uint16(v.data[offset:offset+2])
				offset += 2 + int(length)
			{{else if eq .Type "[]byte"}}
				if offset+2 > len(v.data) {
					return -1
				}
				length = binary.LittleEndian.Uint16(v.data[offset:offset+2])
			{{else if or (eq .Type "uint64") (eq .Type "int64") (eq .Type "float64")}}
				offset += 8

			{{else if or (eq .Type "uint32") (eq .Type "int32") (eq .Type "int") (eq .Type "float32") (eq .Type "rune")}}
				offset += 4

			{{else if or (eq .Type "uint16") (eq .Type "int16")}}
				offset += 2

			{{else if or (eq .Type "uint8") (eq .Type "int8") (eq .Type "byte") (eq .Type "bool")}}
				offset += 1

			{{else if and .IsStruct (not .IsSlice)}}
				if offset+2 > len(v.data) {
					return -1
				}
				length = binary.LittleEndian.Uint16(v.data[offset:offset+2])
				offset += 2 + int(length)
			{{else if and .IsPointer (not .IsPointerSlice)}}
				offset += 1 // non-nil marker
				if offset > 0 && offset-1 < len(v.data) && v.data[offset-1] != 0 {
					if offset+2 > len(v.data) {
						return -1
					}
					length := binary.LittleEndian.Uint16(v.data[offset:offset+2])
					offset += 2 + int(length)
				}
			{{else if or  .IsSlice .IsPointerSlice }}
				if offset+2 > len(v.data) {
					return -1
				}
				length = binary.LittleEndian.Uint16(v.data[offset:offset+2])
				offset += 2
				{{if eq .Type "[]byte"}}
					offset += int(length)
				{{else}}
					// Simplified: assumes fixed-size elements or nested structs
					for i := 0; i < int(length); i++ {
						if offset+2 > len(v.data) {
							return -1
						}
						elemLen := binary.LittleEndian.Uint16(v.data[offset:offset+2])
						offset += 2 + int(elemLen)
					}
				{{end}}
			{{else}}
				offset += 8 // conservative estimate for unknown types
			{{end}}
		{{end}}
	{{end}}
	return offset
}

// ToStruct converts the view to a regular struct (performs copying)
func (v *{{.Name}}View) ToStruct() (*{{.Name}}, error) {
	var s {{.Name}}
	err := s.UnmarshalBinary(v.data)
	return &s, err
}
	{{end}}


	// Encode creates a deterministic encoding of fields with "enc" tag
func (s *{{.Name}}) Encode() ([]byte, error) {
	var result []byte
	
	{{range sortedEncFields .Fields}}
	// Field: {{.Name}} (tag: {{.BinaryTag}})
	// IsBasicType: {{.IsBasicType}}
	
	{
		{{ if or .IsPointer .IsPointerSlice .IsBasicPointerType }}
			if s.{{.Name}} == nil {
				goto SKIP{{.Name}}
			}
		{{end}}

		{
		

		{{if .IsSlice}}
				vv := (s.{{.Name}})
				_ = vv
			{{else if .IsStruct}}
				vv := (s.{{.Name}})
				_ = vv

			{{else if and .IsPointer (not .IsPointerSlice)}}
				vv := {{.CustomElementTypeName}}({{.PointerDeref}}(s.{{.Name}}))
				_ = vv
			{{else}}
				
				vv := {{.CustomTypeName}}({{.PointerDeref}}(s.{{.Name}}))
				_ = vv
		{{end}}
			
		{{ if .IsCustomEncoder }}
		 	{{ if or .IsSlice .IsPointerSlice}}
				for _, item := range vv {
					b, err := ({{.CustomEncoder}}.Encode(item))
					if err != nil {
						return nil, fmt.Errorf("failed to encode field {{.Name}}: %v", err)
					}
					result = append(result, (b)...)
				}
			{{else}}
				_b, err := {{ .CustomEncoder }}.Encode(vv)
				if err != nil {
						return nil, fmt.Errorf("failed to encode field {{.Name}}: %v", err)
					}
				if len(_b) > 0 {
					result = append(result, _b...)
				}
			{{end}}
		{{else if .IsBasicType}}
			{{if eq .Type "string"}}
				result = append(result, []byte(vv)...)

			{{else if eq .Type "[]byte"}}
				result = append(result, vv...)

	
			{{else if or (eq .Type "int64") (eq .Type "int") (eq .Type "uint64") }}
				result = appendUint64(result, uint64(vv))

			{{else if eq .Type "float64"}}
				result = appendUint64(result, math.Float64bits(vv))

			{{else if or (eq .Type "int32") (eq .Type "uint32") (eq .Type "rune")}}
				result = appendUint32(result, uint32(vv))

			{{else if eq .Type "float32"}}
				result = appendUint32(result, math.Float32bits(vv))


			{{else if or (eq .Type "uint16") (eq .Type "int16")}}
				result = appendUint16(result, uint16(vv))

			{{else if or (eq .Type "uint8") (eq .Type "int8") (eq .Type "byte")}}
				result = append(result, uint8(vv))


			{{else if eq .Type "bool"}}
				if s.{{.Name}} {
					result = append(result, 1)
				} else {
					result = append(result, 0)
				}

			{{else}}
				// Fallback for custom or unknown types if needed
				result = append(result, s.{{.Name}}.MarshalBinary()...)
			{{end}}
		{{else if and .IsStruct (not .IsSlice)}}
			{{if .HasEncTag}}
				data, err := s.{{.Name}}.Encode()
				if err != nil {
					return nil, fmt.Errorf("failed to encode nested struct {{.Name}}: %v", err)
				}
				result = append(result, data...)
			{{end}}
		{{else if and .IsPointer (not .IsPointerSlice) }}

			
			{{if eq .ElementType "bool"}}
				if *s.{{.Name}} {
					result = append(result, 1)
				} else {
					result = append(result, 0)
				}

			{{else if eq .ElementType "string"}}
				result = append(result, []byte(*s.{{.Name}})...)

			{{else if eq .ElementType "[]byte"}}
				result = append(result, []byte(*s.{{.Name}}...))

			{{else if eq .ElementType "uint64"}}
				result = appendUint64(result, uint64(*s.{{.Name}}))

			{{else if eq .ElementType "uint32"}}
				result = appendUint32(result, uint32(*s.{{.Name}}))

			{{else if eq .ElementType "uint16"}}
				result = appendUint16(result, uint16(*s.{{.Name}}))

			{{else if eq .ElementType "uint8"}}
				result = append(result,uint8(*s.{{.Name}}))

			{{else if eq .ElementType "int64"}}
				result = appendUint64(result, uint64(*s.{{.Name}}))

			{{else if eq .ElementType "int32"}}
				result = appendUint32(result, uint32(*s.{{.Name}}))

			{{else if eq .ElementType "int16"}}
				result = appendUint16(result, uint16(*s.{{.Name}}))

			{{else if eq .ElementType "int8"}}
				result = append(result, byte(*s.{{.Name}}))

			{{else if eq .ElementType "int"}}
				result = appendUint64(result, uint64(*s.{{.Name}}))

			{{else if eq .ElementType "float32"}}
				result = appendUint32(result, math.Float32bits(*s.{{.Name}}))

			{{else if eq .ElementType "float64"}}
				result = appendUint64(result, math.Float64bits(*s.{{.Name}}))
	
			{{else if .IsStruct}}
				{{if .HasEncTag}}
					data, err := s.{{.Name}}.Encode()
					if err != nil {
						return nil, fmt.Errorf("failed to encode nested struct pointer {{.Name}}: %v", err)
					}
					result = append(result, data...)
				{{end}}
			{{end}}
		{{else if or .IsSlice (.IsPointerSlice)}}
			// IsSlice: {{.IsSlice}}
			// Type: {{.Type}}
			// ElementType: {{.ElementType}}
			// PointerToSlice: {{.IsPointerSlice}}
				
			{{if eq .ElementType "string"}}
				for _, item := range vv {
					result = append(result, []byte(item)...)
				}

			{{else if eq .ElementType "[]byte"}}
				for _, item := range vv {
					result = append(result, item...)
				}

			{{else if eq .ElementType "uint64"}}
				for _, item := range vv {
					result = appendUint64(result, item)
				}

			{{else if eq .ElementType "int64"}}
				for _, item := range vv {
					result = appendUint64(result, uint64(item))
				}

			{{else if eq .ElementType "float64"}}
				for _, item := range vv {
					result = appendUint64(result, math.Float64bits(item))
				}

			{{else if eq .ElementType "uint32"}}
				for _, item := range vv {
					result = appendUint32(result, item)
				}

			{{else if eq .ElementType "int32"}}
				for _, item := range vv {
					result = appendUint32(result, uint32(item))
				}

			{{else if eq .ElementType "int"}}
			//// ElementType: {{.ElementType}}
				for _, item := range vv {
					result = appendUint32(result, uint32(item))
				}

			{{else if eq .ElementType "float32"}}
				for _, item := range vv {
					result = appendUint32(result, math.Float32bits(item))
				}

			{{else if eq .ElementType "uint16"}}
				for _, item := range vv {
					result = appendUint16(result, item)
				}

			{{else if eq .ElementType "int16"}}
				for _, item := range vv {
					result = appendUint16(result, uint16(item))
				}

			{{else if or (eq .ElementType "uint8") (eq .ElementType "byte")}}
				for _, item := range vv {
					result = append(result, item)
				}

			{{else if eq .ElementType "int8"}}
				for _, item := range vv {
					result = append(result, byte(item))
				}

			{{else if eq .ElementType "bool"}}
				for _, item := range vv {
					if item {
						result = append(result, 1)
					} else {
						result = append(result, 0)
					}
				}

			{{else if eq .ElementType "rune"}}
				for _, item := range vv {
					result = appendUint32(result, uint32(item))
				}
			{{else if .IsStruct}}
			 ////// Type {{.ElementType}}
				{{if .HasEncTag}}
					for i, item := range s.{{.Name}} {
						_ = i
						data, err := item.Encode()
						if err != nil {
							return nil, fmt.Errorf("failed to encode struct slice element {{.Name}}[%d]: %v", i, err)
						}
						result = append(result, data...)
					}
				{{else}}
					return nil, fmt.Errorf("struct slice {{.Name}} does not support deterministic encoding")
				{{end}}
				{{end}}
			{{else if .IsPointerElement}}
			
				{{if .IsStruct}}
					for i, item := range vv {
						_ = i
						if item == nil {
							return nil, fmt.Errorf("cannot encode nil pointer in slice {{.Name}}[%d]", i)
						}
						data, err := item.Encode()
						if err != nil {
							return nil, fmt.Errorf("failed to encode struct pointer slice element {{.Name}}[%d]: %v", i, err)
						}
						result = append(result, data...)
					}
				
				{{if eq .ElementType "uint64"}}
					for i, item := range vv {
						_ = i
						if item == nil {
							return nil, fmt.Errorf("nil pointer in slice {{.Name}}[%d]", i)
						}
						result = appendUint64(result, *item)
					}

				{{else if eq .ElementType "int64"}}
					for i, item := range vv {
						_ = i
						if item == nil {
							return nil, fmt.Errorf("nil pointer in slice {{.Name}}[%d]", i)
						}
						result = appendUint64(result, uint64(*item))
					}

				{{else if eq .ElementType "float64"}}
					for i, item := range vv {
						_ = i
						if item == nil {
							return nil, fmt.Errorf("nil pointer in slice {{.Name}}[%d]", i)
						}
						result = appendUint64(result, math.Float64bits(*item))
					}

				{{else if eq .ElementType "uint32"}}
					for i, item := range vv {
						_ = i
						if item == nil {
							return nil, fmt.Errorf("nil pointer in slice {{.Name}}[%d]", i)
						}
						result = appendUint32(result, *item)
					}

				{{else if eq .ElementType "int32"}}
					for i, item := range vv {
						_ = i
						if item == nil {
							return nil, fmt.Errorf("nil pointer in slice {{.Name}}[%d]", i)
						}
						result = appendUint32(result, uint32(*item))
					}

				{{else if eq .ElementType "int"}}
				
					for i, item := range vv {
						_ = i
						if item == nil {
							return nil, fmt.Errorf("nil pointer in slice {{.Name}}[%d]", i)
						}
						result = appendUint32(result, uint32(*item))
					}

				{{else if eq .ElementType "float32"}}
					for i, item := range vv {
						_ = i
						if item == nil {
							return nil, fmt.Errorf("nil pointer in slice {{.Name}}[%d]", i)
						}
						result = appendUint32(result, math.Float32bits(*item))
					}

				{{else if eq .ElementType "uint16"}}
					for i, item := range vv {
						_ = i
						if item == nil {
							return nil, fmt.Errorf("nil pointer in slice {{.Name}}[%d]", i)
						}
						result = appendUint16(result, *item)
					}

				{{else if eq .ElementType "int16"}}
					for i, item := range vv {
						_ = i
						if item == nil {
							return nil, fmt.Errorf("nil pointer in slice {{.Name}}[%d]", i)
						}
						result = appendUint16(result, uint16(*item))
					}

				{{else if or (eq .ElementType "uint8") (eq .ElementType "byte")}}
					for i, item := range vv {
						_ = i
						if item == nil {
							return nil, fmt.Errorf("nil pointer in slice {{.Name}}[%d]", i)
						}
						result = append(result, *item)
					}

				{{else if eq .ElementType "int8"}}
					for i, item := range vv {
						_ = i
						if item == nil {
							return nil, fmt.Errorf("nil pointer in slice {{.Name}}[%d]", i)
						}
						result = append(result, byte(*item))
					}

				{{else if eq .ElementType "bool"}}
					for i, item := range vv {
						_ = i
						if item == nil {
							return nil, fmt.Errorf("nil pointer in slice {{.Name}}[%d]", i)
						}
						if *item {
							result = append(result, 1)
						} else {
							result = append(result, 0)
						}
					}

				{{else if eq .ElementType "string"}}
					for i, item := range vv {
						if item == nil {
							return nil, fmt.Errorf("nil pointer in slice {{.Name}}[%d]", i)
						}
						if len(*item) > MaxStringLen {
							return nil, fmt.Errorf("{{.Name}}[%d] too long: %d bytes, max %d", i, len(*item), MaxStringLen)
						}
						result = appendUint16(result, uint16(len(*item)))
						result = append(result, []byte(*item)...)
					}

				{{else if eq .ElementType "[]byte"}}
					for i, item := range vv {
						if item == nil {
							return nil, fmt.Errorf("nil pointer in slice {{.Name}}[%d]", i)
						}
						if len(*item) > MaxSliceLen {
							return nil, fmt.Errorf("{{.Name}}[%d] too long: %d bytes, max %d", i, len(*item), MaxSliceLen)
						}
						result = appendUint16(result, uint16(len(*item)))
						result = append(result, *item...)
					}

				{{else}}
					return nil, fmt.Errorf("unsupported pointer slice type in field {{.Name}}")
				{{end}}

			
			{{else}}
			
				{{if .HasEncTag}}
					for i, item := range s.{{.Name}} {
						_ = i
						data, err := item.Encode()
						if err != nil {
							return nil, fmt.Errorf("failed to encode struct slice element {{.Name}}[%d]: %v", i, err)
						}
						result = append(result, data...)
					}
				{{else}}
					return nil, fmt.Errorf("struct slice {{.Name}} does not support deterministic encoding")
				{{end}}
				// return nil, fmt.Errorf("unsupported slice type in field {{.Name}}")
			{{end}}
		{{else}}
		
			{{if .HasEncTag}}
				data, err := s.{{.Name}}.Encode()
				if err != nil {
					return nil, fmt.Errorf("failed to encode nested struct {{.Name}}: %v", err)
				}
				result = append(result, data...)
			{{else}}
				return nil, fmt.Errorf("nested struct {{.Name}} does not support deterministic encoding")
			{{end}}
		{{end}}

		}
		{{ if or .IsPointer .IsPointerSlice .IsBasicPointerType }}
			 SKIP{{.Name}}:
		{{end}}

	}
	{{end}}

	return result, nil
}

{{if $options.ZeroCopy}}
// ToView converts the struct to a zero-copy view
func (s *{{.Name}}) ToView() (*{{.Name}}View, error) {
	data, err := s.MarshalBinary()
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to binary: %v", err)
	}
	return New{{.Name}}View(data)
}
{{end}}

// MarshalBinary encodes {{.Name}} to binary format
func (s {{.Name}}) MarshalBinary() ([]byte, error) {
	{{if $options.UsePooling}}
		buf := binaryBufPool.Get().([]byte)
		buf = buf[:0]
		defer binaryBufPool.Put(buf)
		{{else}}
		var buf []byte
	{{end}}

	// Calculate size first
	size := s.BinarySize()
	{{if $options.UsePooling}}
	if cap(buf) < size {
		buf = make([]byte, 0, size)
	}
	{{else}}
		buf = make([]byte, 0, size)
	{{end}}

	{{range .Fields}}
		{{if not .ShouldIgnore}}
		{
		{{if .IsPointer}}
		if s.{{.Name}} == nil {
			buf = append(buf, 0) // nil marker
			goto SKIP{{.Name}}
		} else {
		 	buf = append(buf, 1) // non-nil marker
		}

		{{end}}
		

				{{if not .IsBasicType}}
					cc := (s.{{.Name}})
					_ = cc
				{{end}}
			{{if .IsCustomEncoder }}
					// {{.Name}} ({{.BinaryTag}}) - custom encoder
					// IsCustomEncoder: {{.IsCustomEncoder}}
					// ElementType: {{.ElementType}}
					// PointerToSlice: {{.IsPointerSlice}}
					{{if or .IsSlice .IsPointerSlice}}
					if len({{.PointerDeref}}(s.{{.Name}})) > MaxSliceLen {
						return nil, fmt.Errorf("{{.Name}} slice too long: %d elements, max %d", len({{.PointerDeref}}(s.{{.Name}})), MaxSliceLen)
					}
					buf = appendUint16(buf, uint16(len({{.PointerDeref}}(s.{{.Name}}))))

						for _, item := range {{.PointerDeref}}(s.{{.Name}}) {
							data, err := {{.CustomEncoder}}.MarshalBinary(item)
							if err != nil {
								return nil, fmt.Errorf("failed to marshal item in slice {{.Name}}: %v", err)
							}
							buf = appendBytes(buf, data)
						}
					{{else}}
						data, err := {{.CustomEncoder}}.MarshalBinary({{.PointerDeref}}(s.{{.Name}}))
						if err != nil {
							return nil, fmt.Errorf("failed to marshal {{.Name}}: %v", err)
						}
						buf = appendBytes(buf, data)
					{{end}}
			
			{{else if and .IsBasicType (not  .IsSlice) }}
				// {{.Name}} ({{.BinaryTag}}) - {{.Type}}
				// IsBasicType {{ .IsBasicType }}
				// ElementType {{ .ElementType }}

				cc := {{.Type}}(s.{{.Name}})
				_ = cc
				{{if eq .ElementType "string"}}
				if len(cc) > MaxStringLen {
					return nil, fmt.Errorf("{{.Name}} too long: %d bytes, max %d", len(cc), MaxStringLen)
				}
				buf = appendBytes(buf, []byte(cc))

				{{else if eq .ElementType "[]byte"}}
				if len(cc) > MaxSliceLen {
					return nil, fmt.Errorf("{{.Name}} too long: %d bytes, max %d", len(cc), MaxSliceLen)
				}
				buf = appendBytes(buf, cc)

				{{else if or (eq .ElementType "uint32") ( eq .ElementType "int32")}}
				 buf = appendUint32(buf, uint32(cc))

				{{else if or (eq .ElementType "int64") (eq .ElementType "uint64") (eq .ElementType "int")}}
				buf = appendUint64(buf, uint64(cc))

				{{else if or (eq .ElementType "int16") (eq .ElementType "uint16") }}
				buf = appendUint16(buf, uint16(cc))
				
				{{else if or (eq .ElementType "int8") (eq .ElementType "uint8") }}
					buf = append(buf, uint8(cc))
				{{else if eq .ElementType "float32"}}
					buf = appendUint32(buf, math.Float32bits(cc))

				{{else if eq .ElementType "float64"}}
					buf = appendUint64(buf, math.Float64bits(cc))

				{{else if eq .Type "bool"}}
				if cc {
					buf = append(buf, 1)
				} else {
					buf = append(buf, 0)
				}
				{{end}}
			
			{{else if and .IsStruct (not .IsSlice)}}
				// {{.Name}} ({{.BinaryTag}}) - nested struct
				nestedData, err := s.{{.Name}}.MarshalBinary()
				if err != nil {
					return nil, fmt.Errorf("failed to marshal nested struct {{.Name}}: %v", err)
				}
				buf = appendBytes(buf, nestedData)

			{{else if and .IsPointer (not .IsPointerSlice) }}
				// {{.Name}} ({{.BinaryTag}}) - pointer
					{{if eq .ElementType "bool"}}
					if *s.{{.Name}} {
						buf = append(buf, 1)
					} else {
						buf = append(buf, 0)
					}

					{{else if eq .ElementType "string"}}
					// ElementType: {{.ElementType}}
					str := *s.{{.Name}}
					if len(str) > MaxStringLen {
						return nil, fmt.Errorf("{{.Name}} too long: %d bytes, max %d", len(str), MaxStringLen)
					}
					buf = appendBytes(buf, []byte(str))

					{{else if eq .ElementType "[]byte"}}
						bytes := *s.{{.Name}}
						if len(bytes) > MaxSliceLen {
							return nil, fmt.Errorf("{{.Name}} too long: %d bytes, max %d", len(bytes), MaxSliceLen)
						}
						buf = appendBytes(buf, bytes)

					{{else if or  (eq .ElementType "uint64")  (eq .ElementType "int64")  (eq .ElementType "int")  }}
					buf = appendUint64(buf, uint64(*s.{{.Name}}))

					{{else if or  (eq .ElementType "uint32")  (eq .ElementType "int32")  }}
					buf = appendUint32(buf,  uint32(*s.{{.Name}}))

					{{else if or  (eq .ElementType "uint16")  (eq .ElementType "int16")  }}
					buf = appendUint16(buf, uint16(*s.{{.Name}}))

					{{else if or  (eq .ElementType "uint8")  (eq .ElementType "int8")  }}
					
					buf = append(buf, uint8(*s.{{.Name}}))
		

					{{else if eq .ElementType "float32"}}
					buf = appendUint32(buf, math.Float32bits(*s.{{.Name}}))

					{{else if eq .ElementType "float64"}}
					buf = appendUint64(buf, math.Float64bits(*s.{{.Name}}))

					{{else if .IsStruct}}
					nestedData, err := s.{{.Name}}.MarshalBinary()
					if err != nil {
						return nil, fmt.Errorf("failed to marshal nested struct pointer {{.Name}}: %v", err)
					}
					buf = appendBytes(buf, nestedData)

					{{else}}
					data, err := marshalValue(s.{{.Name}})
					if err != nil {
						return nil, fmt.Errorf("failed to marshal pointer {{.Name}}: %v", err)
					}
					buf = appendBytes(buf, data)
					{{end}}
				
				
			{{else if or .IsSlice (.IsPointerSlice) }}
				// {{.Name}} ({{.BinaryTag}}) - slice
				// ElementType: {{.ElementType}}
				// Type: {{ .Type }}

				{
				mm := ({{ .PointerDeref }}(s.{{.Name}}))
			
			
				if len(mm) > MaxSliceLen {
					return nil, fmt.Errorf("{{.Name}} slice too long: %d elements, max %d", len(mm), MaxSliceLen)
				}
				buf = appendUint16(buf, uint16(len(mm)))

				{{if eq .Type "[]byte"}}
					buf = append(buf, []byte(s.{{.Name}})...)

				{{else if .IsStruct}}
					for i, item := range s.{{.Name}} {
						_ = i
						itemData, err := item.MarshalBinary()
						if err != nil {
							return nil, fmt.Errorf("failed to marshal struct slice element {{.Name}}[%d]: %v", i, err)
						}
						buf = appendBytes(buf, itemData)
					}

				{{else}}
						for i, item := range mm {
							_ = i

							{{if eq .ElementType "string"}}
								if len(item) > MaxStringLen {
									return nil, fmt.Errorf("{{.Name}}[%d] too long: %d bytes, max %d", i, len(item), MaxStringLen)
								}
								itemData := []byte(item)
								buf = appendBytes(buf, itemData)
							{{else if eq .ElementType "byte"}}
								
								// itemData := []byte(item)
								buf = appendBytes(buf, []byte{item})

							{{else if eq .ElementType "[]byte"}}
								if len(item) > MaxSliceLen {
									return nil, fmt.Errorf("{{.Name}}[%d] too long: %d bytes, max %d", i, len(item), MaxSliceLen)
								}
								buf = appendBytes(buf, item)
							{{else if or  (eq .ElementType "uint64")  (eq .ElementType "int64")  (eq .ElementType "int")  }}
								buf = appendUint64(buf, uint64(item))

							{{else if or  (eq .ElementType "uint32")  (eq .ElementType "int32")  }}
								buf = appendUint32(buf, uint32(item))

							{{else if or  (eq .ElementType "uint16")  (eq .ElementType "int16")  }}
								buf = appendUint16(buf, uint16(item))

							{{else if or  (eq .ElementType "uint8")  (eq .ElementType "int8")  }}
								buf = append(buf, uint8(item))
							
							{{else if eq .ElementType "float32"}}
								buf = appendUint32(buf, math.Float32bits(item))

							{{else if eq .ElementType "float64"}}
								buf = appendUint64(buf, math.Float64bits(item))

							{{else if eq .ElementType "bool"}}
								if item {
									buf = append(buf, 1)
								} else {
									buf = append(buf, 0)
								}
							{{else}}
								data, err := marshalValue(item)
								if err != nil {
									return nil, fmt.Errorf("failed to marshal slice element {{.Name}}[%d]: %v", i, err)
								}
								buf = appendBytes(buf, data)
							{{end}}
						}
				{{end}}
				}
	
			{{else}}
				// {{.Name}} ({{.BinaryTag}}) - custom type
				data, err := marshalValue(s.{{.Name}})
				if err != nil {
					return nil, fmt.Errorf("failed to marshal custom type {{.Name}}: %v", err)
				}
				buf = appendBytes(buf, data)
			{{end}}
			
			}
			{{if .IsPointer}}
					SKIP{{.Name}}:
				{{end}}
		{{end}}
	{{end}}

	{{if $options.UsePooling}}
		// Copy result before returning buffer to pool
		result := make([]byte, len(buf))
		copy(result, buf)
		return result, nil
		{{else}}
		return buf, nil
	{{end}}
}


// UnmarshalBinary decodes binary data to {{.Name}}
func (s *{{.Name}}) UnmarshalBinary(data []byte) error {
    offset := 0
    var err error
    {{range .Fields}}
    {{if not .ShouldIgnore}}
	
	
    {
	{{ if  or .IsPointer .IsBasicPointerType .IsPointerSlice}}
			
			ptr := data[offset]
			if int(ptr) == 0 {
				s.{{.Name }} = nil
				offset++
				goto SKIP{{.Name}}
			} 
				offset++
				
	{{ end }}
		 {
        // {{.Name}} ({{.BinaryTag}})
		// Type - {{.Type}}
		// IsPointer - {{.IsPointer}}
		 // ElementType - {{.ElementType}}
		
		{{if .IsCustomEncoder }}
			// Custom encoder
			// IsCustomEncoder: {{.IsCustomEncoder}}
			// ElementType: {{.ElementType}}
			// PointerToSlice: {{.IsPointerSlice}}
			
			{{if or .IsSlice .IsPointerSlice}}
				var length uint16
				if offset+2 > len(data) {
					return fmt.Errorf("buffer too short for {{.Name}} length")
				}
				length = binary.LittleEndian.Uint16(data[offset : offset+2])
				offset += 2
				p := make([]{{.CustomElementTypeName}}, length)
				
				for i := 0; i < int(length); i++ {
					var itemData []byte
					itemData, offset, err = getBytes(data, offset)
					if err != nil {
						return fmt.Errorf("failed to get bytes for custom encoder slice {{.Name}}[%d]: %v", i, err)
					}
					if _v, err := {{.CustomEncoder}}.UnmarshalBinary(itemData); err != nil {
						return fmt.Errorf("failed to unmarshal custom encoder slice {{.Name}}[%d]: %v", i, err)
					} else {
						p[i] = _v.({{.CustomElementTypeName}})
					}
				}
					
					s.{{.Name}} = {{.PointerRef}}p
			{{else}}
				var itemData []byte
				itemData, offset, err = getBytes(data, offset)
				if err != nil {	
					return fmt.Errorf("failed to get bytes for custom encoder {{.Name}}: %v", err)	
				}
				b, err := {{.CustomEncoder}}.UnmarshalBinary(itemData)
				if err != nil {
					return fmt.Errorf("failed to unmarshal custom encoder {{.Name}}: %v", err)
				}
					p := b.({{.CustomElementTypeName}})
					s.{{.Name}} = {{.PointerRef}}p
			{{end}}


        {{else if or .IsBasicType (.IsBasicPointerType) }}

			
          		 {{ unmarshalBasicTypeTemplate . }}

        {{else if  and .IsStruct (not .IsSlice)}}
            // Nested struct
            var nestedData []byte
            nestedData, offset, err = getBytes(data, offset)
            if err != nil {
                return fmt.Errorf("failed to get bytes for nested struct {{.Name}}: %v", err)
            }
            if err = s.{{.Name}}.UnmarshalBinary(nestedData); err != nil {
                return fmt.Errorf("failed to unmarshal nested struct {{.Name}}: %v", err)
            }
        {{else if and .IsPointer (not .IsPointerSlice)}}
            // Pointer
            if offset >= len(data) {
                return fmt.Errorf("buffer too short for {{.Name}} nil marker")
            }
            if int(data[offset]) == 0 {
                s.{{.Name}} = nil
                offset++
            } else {
                offset++
                {{if .IsBasicType }}
					{{ unmarshalBasicTypeTemplate . }}
                {{else if .IsStruct}}
					var nestedData []byte
					nestedData, offset, err = getBytes(data, offset)
					if err != nil {
						return fmt.Errorf("failed to get bytes for nested struct pointer {{.Name}}: %v", err)
					}
					s.{{.Name}} = &{{.ElementType}}{}
					if err = s.{{.Name}}.UnmarshalBinary(nestedData); err != nil {
						return fmt.Errorf("failed to unmarshal nested struct pointer {{.Name}}: %v", err)
					}
                {{else}}
					var val {{.ElementType}}
					var valueData []byte
					valueData, offset, err = getBytes(data, offset)
					if err != nil {
						return fmt.Errorf("failed to get bytes for pointer {{.Name}}: %v", err)
					}
					if err = unmarshalValue(valueData, {{.ElementPointerRef}}val); err != nil {
						return fmt.Errorf("failed to unmarshal pointer {{.Name}}: %v", err)
					}
					s.{{.Name}} = {{.ElementPointerRef}}val
                {{end}}
            }
        {{else if  or .IsSlice (.IsPointerSlice)}}
            // Slice
			// IsPointerSlice {{.IsPointerSlice}}
			// IsBasicType {{.IsBasicType}}
			// CustomeElementTypeNameicType {{.CustomElementTypeName}}
			// ElementType {{.ElementType}}
			
			if offset+2 > len(data) {
				return fmt.Errorf("buffer too short for {{.Name}} length")
			}
			length := binary.LittleEndian.Uint16(data[offset:offset+2])
			offset += 2
			p := make([]{{.CustomElementTypeName}}, length)
			s.{{.Name}} = {{.PointerRef}}p

			{{if eq .ElementType "byte"}}
				if offset+int(length) > len(data) {
					return fmt.Errorf("buffer too short for {{.Name}} data")
				}
				v := {{.CustomTypeName}}(data[offset:offset+int(length)]) // Zero-copy assignment
				(s.{{.Name}}) = {{.PointerRef}}v
				offset += int(length)

			{{else if eq .ElementType "string"}}
				tmp := make([]{{.CustomElementTypeName}}, length)
				for i := 0; i < int(length); i++ {
					var strData []byte
					strData, offset, err = getBytes(data, offset)
					if err != nil {
						return fmt.Errorf("failed to decode string for {{.Name}}[%d]: %v", i, err)
					}
					tmp[i] = {{.CustomElementTypeName}}(string(strData))
				}
				((s.{{.Name}})) = {{.PointerRef}}tmp

			{{else if or (eq .ElementType "int8") (eq .ElementType "uint8") (eq .ElementType "bool")}}
				tmp := make([]{{.CustomElementTypeName}}, length)
				for i := 0; i < int(length); i++ {
					if offset >= len(data) {
						return fmt.Errorf("buffer too short for {{.Name}}[%d] 1-byte value", i)
					}
					tmp[i] = {{.CustomElementTypeName}}(data[offset])
					offset++
				}
				((s.{{.Name}})) = {{.PointerRef}}tmp

			{{else if or (eq .ElementType "int16") (eq .ElementType "uint16")}}
				tmp := make([]{{.CustomElementTypeName}}, length)
				for i := 0; i < int(length); i++ {
					if offset+2 > len(data) {
						return fmt.Errorf("buffer too short for {{.Name}}[%d] 2-byte value", i)
					}
					tmp[i] = {{.CustomElementTypeName}}(binary.LittleEndian.Uint16(data[offset:]))
					offset += 2
				}
				(s.{{.Name}}) = {{.PointerRef}}tmp

			{{else if or (eq .ElementType "int32") (eq .ElementType "uint32")}}
				tmp := make([]{{.CustomElementTypeName}}, length)
				for i := 0; i < int(length); i++ {
					if offset+4 > len(data) {
						return fmt.Errorf("buffer too short for {{.Name}}[%d] 4-byte value", i)
					}
					tmp[i] = {{.CustomElementTypeName}}(binary.LittleEndian.Uint32(data[offset:]))
					offset += 4
				}
				((s.{{.Name}})) = {{.PointerRef}}tmp

			{{else if or (eq .ElementType "int64") (eq .ElementType "uint64")}}
				tmp := make([]{{.CustomElementTypeName}}, length)
				for i := 0; i < int(length); i++ {
					if offset+8 > len(data) {
						return fmt.Errorf("buffer too short for {{.Name}}[%d] 8-byte value", i)
					}
					tmp[i] = {{.CustomElementTypeName}}(binary.LittleEndian.Uint64(data[offset:]))
					offset += 8
				}
				(s.{{.Name}}) = {{.PointerRef}}tmp

			{{else if eq .ElementType "float32"}}
				tmp := make([]{{.CustomElementTypeName}}, length)
				for i := 0; i < int(length); i++ {
					if offset+4 > len(data) {
						return fmt.Errorf("buffer too short for {{.Name}}[%d] float32", i)
					}
					tmp[i] = {{.CustomElementTypeName}}(math.Float32frombits(binary.LittleEndian.Uint32(data[offset:])))
					offset += 4
				}
				(s.{{.Name}}) = {{.PointerRef}}tmp

			{{else if eq .ElementType "float64"}}
				tmp := make([]{{.CustomElementTypeName}}, length)
				for i := 0; i < int(length); i++ {
					if offset+8 > len(data) {
						return fmt.Errorf("buffer too short for {{.Name}}[%d] float64", i)
					}
					tmp[i] = {{.CustomElementTypeName}}(math.Float64frombits(binary.LittleEndian.Uint64(data[offset:])))
					offset += 8
				}
				(s.{{.Name}}) = {{.PointerRef}}tmp

			{{else if or (eq .ElementType "int") (eq .ElementType "uint")}}
				// Assuming platform-default 64-bit
				tmp := make([]{{.CustomElementTypeName}}, length)
				for i := 0; i < int(length); i++ {
					if offset+8 > len(data) {
						return fmt.Errorf("buffer too short for {{.Name}}[%d] platform int", i)
					}
					tmp[i] = {{.CustomElementTypeName}}(binary.LittleEndian.Uint64(data[offset:]))
					offset += 8
				}
				(s.{{.Name}}) = {{.PointerRef}}tmp
			

			{{else if .IsCustomType}}
				tmp := make([]{{.CustomElementTypeName}}, length)
				for i := 0; i < int(length); i++ {
					item := new({{.ElementType}})
					if err := (item).UnmarshalBinary(data); err != nil {
						return fmt.Errorf("failed to decode custom type for {{.Name}}[%d]: %v", i, err)
					}
					tmp[i] = {{.CustomElementTypeName}}(*item)
					offset += 2 + len(data)
				}
				(s.{{.Name}}) = {{.PointerRef}}tmp
            {{else if eq .Type "[]byte"}}
				tmp := make([]{{.CustomElementTypeName}}, length)
				for i := 0; i < int(length); i++ {
					var strData []byte
					strData, offset, err = getBytes(data, offset)
					if err != nil {
						return fmt.Errorf("failed to decode string for {{.Name}}[%d]: %v", i, err)
					}
					tmp[i] = {{.CustomElementTypeName}}(strData)
				}
				((s.{{.Name}})) = {{.PointerRef}}tmp
            {{else if .IsStruct}} // TODO
				for i := 0; i < int(length); i++ {
					var itemData []byte
					itemData, offset, err = getBytes(data, offset)
					if err != nil {
						return fmt.Errorf("failed to get bytes for struct slice element {{.Name}}[%d]: %v", i, err)
					}
					if err = ({{.PointerDeref}}(s.{{.Name}}))[i].UnmarshalBinary(itemData); err != nil {
						return fmt.Errorf("failed to unmarshal struct slice element {{.Name}}[%d]: %v", i, err)
					}
				}
            // ({{.PointerDeref}}(s.{{.Name}})) = {{.CustomTypeName}}(vv)
            {{else}}
            for i := 0; i < int(length); i++ {
               	{{if eq .ElementType "string"}}
					var itemData []byte
					itemData, offset, err = getBytes(data, offset)
					if err != nil {
						return fmt.Errorf("failed to get bytes for string slice element {{.Name}}[%d]: %v", i, err)
					}
					val := {{.CustomElementTypeName}}(string(itemData))
					({{.PointerDeref}}(s.{{.Name}}))[i] = {{.ElementPointerRef}}val

				{{else if eq .ElementType "[]byte"}}
					var itemData []byte
					itemData, offset, err = getBytes(data, offset)
					if err != nil {
						return fmt.Errorf("failed to get bytes for []byte slice element {{.Name}}[%d]: %v", i, err)
					}
					val := {{.CustomElementTypeName}}(itemData)
					({{.PointerDeref}}(s.{{.Name}}))[i] = {{.ElementPointerRef}}val

				{{else if eq .ElementType "uint64"}}
					if offset+8 > len(data) {
						return fmt.Errorf("buffer too short for {{.Name}}[%d]", i)
					}
					val := {{.CustomElementTypeName}}(binary.LittleEndian.Uint64(data[offset:]))
					offset += 8
					({{.PointerDeref}}(s.{{.Name}}))[i] = {{.ElementPointerRef}}val


				{{else if eq .ElementType "uint32"}}
					if offset+4 > len(data) {
						return fmt.Errorf("buffer too short for {{.Name}}[%d]", i)
					}
					val := {{.CustomElementTypeName}}(binary.LittleEndian.Uint32(data[offset:]))
					offset += 4
					({{.PointerDeref}}(s.{{.Name}}))[i] = {{.ElementPointerRef}}val

				{{else if eq .ElementType "uint16"}}
					if offset+2 > len(data) {
						return fmt.Errorf("buffer too short for {{.Name}}[%d]", i)
					}
					val := {{.CustomElementTypeName}}(binary.LittleEndian.Uint16(data[offset:]))
					offset += 2
					({{.PointerDeref}}(s.{{.Name}}))[i] = {{.ElementPointerRef}}val

				{{else if eq .ElementType "uint8"}}
					if offset+1 > len(data) {
						return fmt.Errorf("buffer too short for {{.Name}}[%d]", i)
					}
					val := {{.CustomElementTypeName}}(data[offset])
					offset++

				{{else if eq .ElementType "int64"}}
					if offset+8 > len(data) {
						return fmt.Errorf("buffer too short for {{.Name}}[%d]", i)
					}
					val := {{.CustomElementTypeName}}(int64(binary.LittleEndian.Uint64(data[offset:])))
					offset += 8
					({{.PointerDeref}}(s.{{.Name}}))[i] = {{.ElementPointerRef}}val
			

				{{else if eq .ElementType "int32"}}
					if offset+4 > len(data) {
						return fmt.Errorf("buffer too short for {{.Name}}[%d]", i)
					}
					val := {{.CustomElementTypeName}}(int32(binary.LittleEndian.Uint32(data[offset:])))
					offset += 4
					({{.PointerDeref}}(s.{{.Name}}))[i] = {{.ElementPointerRef}}val
				

				{{else if eq .ElementType "int16"}}
					if offset+2 > len(data) {
						return fmt.Errorf("buffer too short for {{.Name}}[%d]", i)
					}
					val := {{.CustomElementTypeName}}(int16(binary.LittleEndian.Uint16(data[offset:])))
					offset += 2
					({{.PointerDeref}}(s.{{.Name}}))[i] = {{.ElementPointerRef}}val
				

				{{else if eq .ElementType "int8"}}
					if offset+1 > len(data) {
						return fmt.Errorf("buffer too short for {{.Name}}[%d]", i)
					}
					val := {{.CustomElementTypeName}}(int8(data[offset]))
					offset++
					({{.PointerDeref}}(s.{{.Name}}))[i] = {{.ElementPointerRef}}val
			

				{{else if eq .ElementType "int"}}
					if offset+4 > len(data) {
						return fmt.Errorf("buffer too short for {{.Name}}[%d]", i)
					}
					val := {{.CustomElementTypeName}}(int(binary.LittleEndian.Uint32(data[offset:])))
					offset += 4
					({{.PointerDeref}}(s.{{.Name}}))[i] = {{.ElementPointerRef}}val
				

				{{else if eq .ElementType "float32"}}
					if offset+4 > len(data) {
						return fmt.Errorf("buffer too short for {{.Name}}[%d]", i)
					}
					val := {{.CustomElementTypeName}}(math.Float32frombits(binary.LittleEndian.Uint32(data[offset:])))
					offset += 4
					({{.PointerDeref}}(s.{{.Name}}))[i] = {{.ElementPointerRef}}val
				
				{{else if eq .ElementType "float64"}}
					if offset+8 > len(data) {
						return fmt.Errorf("buffer too short for {{.Name}}[%d]", i)
					}
					val := {{.CustomElementTypeName}}(math.Float64frombits(binary.LittleEndian.Uint64(data[offset:])))
					offset += 8
					({{.PointerDeref}}(s.{{.Name}}))[i] = {{.ElementPointerRef}}val
				
				{{else if eq .ElementType "bool"}}
					if offset >= len(data) {
						return fmt.Errorf("buffer too short for {{.Name}}[%d]", i)
					}
					val := {{.CustomElementTypeName}}(data[offset] != 0)
					offset++
					({{.PointerDeref}}(s.{{.Name}}))[i] = {{.ElementPointerRef}}val
				

				{{else}}
					var itemData []byte
					itemData, offset, err = getBytes(data, offset)
					if err != nil {
						return fmt.Errorf("failed to get bytes for slice element {{.Name}}[%d]: %v", i, err)
					}
						if err = unmarshalValue(itemData, ({{.PointerDeref}}(s.{{.Name}}))[i]); err != nil {
							return fmt.Errorf("failed to unmarshal slice element {{.Name}}[%d]: %v", i, err)
						}
				
					
				{{end}}
				
				
            }
				
            // s.{{.Name}} = {{.CustomTypeName}}(vv)
            {{end}}			
        {{else}}
            // Custom type
            var valueData []byte
            valueData, offset, err = getBytes(data, offset)
            if err != nil {
                return fmt.Errorf("failed to get bytes for custom type {{.Name}}: %v", err)
            }
            if v, ok := interface{}(s.{{.Name}}).(BinaryUnMarshaler); ok {
                if err = v.UnmarshalBinary(valueData); err != nil {
                    return fmt.Errorf("failed to unmarshal custom type {{.Name}}: %v", err)
                }
            } else if err = unmarshalValue(valueData, &s.{{.Name}}); err != nil {
                return fmt.Errorf("failed to unmarshal custom type {{.Name}}: %v", err)
            }
        {{end}}
		}
		{{ if  or .IsPointer .IsBasicPointerType .IsPointerSlice}}
		SKIP{{.Name}}:
		{{end}}
    }
    {{end}}
    {{end}}
    return err
}


{{if $options.ZeroCopy}}
// UnmarshalBinaryZeroCopy creates a zero-copy view
func (s *{{.Name}}) UnmarshalBinaryZeroCopy(data []byte) (*{{.Name}}View, error) {
	return New{{.Name}}View(data)
}
{{end}}

// just a placeholder for the math package
func (s *{{.Name}}) mathPlaceHolder()  bool {
	return math.Ceil(0) == 0
}







// binarySize calculates the size needed for binary encoding
func (s *{{.Name}}) BinarySize() int {
	
	size := 0
	{{range .Fields}}
	{{if not .ShouldIgnore}}
	{
		// {{ .Name }}
		// {{.CustomTypeName}}
		// {{.Type}}
		// {{.ActualType}}
		// {{.CustomElementTypeName}}
		// {{.ElementType}}
			{{ if or .IsPointer .IsPointerSlice}}
			size++
			if s.{{.Name}} == nil {
				goto SKIP{{.Name}}
			}
			{{end}}

		{
		// {{.Name}} ({{.BinaryTag}})
		// Type: {{.Type}}
		// IsPointer: {{.IsPointer}}
		// ElementType: {{.ElementType}}


		{{if .IsCustomEncoder }}
			{{if or .IsSlice .IsPointerSlice}}
			j := ({{.PointerDeref}}s.{{.Name}})
			_ = j
			size += 2 // length prefix
			for i := range j {
				s, err := {{.CustomEncoder}}.BinarySize(j[i])
				if err != nil {
					panic(fmt.Sprintf("failed to calculate binary size for custom encoder {{.Name}}[%d]: %v", i, err))
				}
				size += 2 + s
			}
			{{else}}
			s, err := {{.CustomEncoder}}.BinarySize({{.PointerDeref}}s.{{.Name}})
				if err != nil {
					panic(fmt.Sprintf("failed to calculate binary size for custom encoder {{.Name}}: %v", err))
				}
				size += 2 + s
			{{end}}
		
		  
           

		{{else if  .IsBasicType }}
			{{if eq .Type "string"}}
				size += 2 + len({{.PointerDeref}}s.{{.Name}}) // string: 2-byte length + content
			{{else if eq .Type "[]byte"}}
				size += 2 + len({{.PointerDeref}}s.{{.Name}}) // []byte: 2-byte length + content
			{{else if or (eq .Type "uint64") (eq .Type "int64") (eq .Type "float64")}}
				size += 8 // 64-bit: uint64, int64, float64
			{{else if or (eq .Type "uint32") (eq .Type "int32") (eq .Type "int") (eq .Type "float32") (eq .Type "rune")}}
				size += 4 // 32-bit: uint32, int32, int, float32, rune
			{{else if or (eq .Type "uint16") (eq .Type "int16")}}
				size += 2 // 16-bit: uint16, int16
			{{else if or (eq .Type "uint8") (eq .Type "int8") (eq .Type "byte")}}
				size += 1 // 8-bit: uint8, int8, byte
			{{else if eq .Type "bool"}}
				size += 1 // bool: 1 byte
			{{else}}
				size += 2 + s.{{.Name}}.BinarySize()
			{{end}}
		{{else if and .IsPointer (not .IsPointerSlice) }}
			
			if s.{{.Name}} != nil {
				{{if .IsStruct}}
				size += 2 + s.{{.Name}}.BinarySize()

			{{else if eq .ElementType "string"}}
				ptr := *s.{{.Name}}
				size += 2 + len(ptr)

			{{else if eq .ElementType "[]byte"}}
				ptr := *s.{{.Name}}
				size += 2 + len(ptr)

			{{else if or (eq .ElementType "uint64") (eq .ElementType "int64") (eq .ElementType "float64")}}
				size += 8

			{{else if or (eq .ElementType "uint32") (eq .ElementType "int32") (eq .ElementType "int") (eq .ElementType "float32") (eq .ElementType "rune")}}
				size += 4

			{{else if or (eq .ElementType "uint16") (eq .ElementType "int16")}}
				size += 2

			{{else if or (eq .ElementType "uint8") (eq .ElementType "int8") (eq .ElementType "byte")}}
				size += 1

			{{else if eq .ElementType "bool"}}
				size += 1

			{{else}}
				// Fallback estimate for custom or unknown pointer types
				size += 2 + 64
			{{end}}

			}
		{{else if or .IsSlice (.IsPointerSlice)}}
			{{ if .IsPointerSlice}} 
				if s.{{.Name}} == nil {
					return size
				}
			{{end}}
			j := ({{.PointerDeref}}s.{{.Name}})
			_ = j
			size += 2 // for length prefix
			{{if or (eq .Type "[]byte") (eq .Type "*[]byte")}}
				size += len(j)

			{{else if .IsStruct}}
				for i := range j {
					size += 2 + j[i].BinarySize()
				}

			{{else if eq .ElementType "string"}}
				for _, item := range j {
					size += 2 + len(item)
				}

			{{else if eq .ElementType "[]byte"}}
				for _, item := range j {
					size += 2 + len(item)
				}

			{{else if or (eq .ElementType "uint64") (eq .ElementType "int64") (eq .ElementType "float64")}}
				size += len(j) * 8

			{{else if or (eq .ElementType "uint32") (eq .ElementType "int32") (eq .ElementType "int") (eq .ElementType "float32") (eq .ElementType "rune")}}
				size += len(j) * 4

			{{else if or (eq .ElementType "uint16") (eq .ElementType "int16")}}
				size += len(j) * 2

			{{else if or (eq .ElementType "uint8") (eq .ElementType "int8") (eq .ElementType "byte") (eq .ElementType "bool")}}
				size += len(j)

			{{else}}
				for _, item := range ({{.PointerDeref}}s).{{.Name}} {
					// Fallback: try calling item.BinarySize() if available
					if bs, ok := interface{}(item).(interface{ BinarySize() int }); ok {
						size += 2 + bs.BinarySize()
					} else {
						size += 2 + 64 // conservative default
					}
				}
			{{end}}

		{{else}}
			// Fallback for custom types
			if bs, ok := interface{}(s.{{.Name}}).(interface{ BinarySize() int }); ok {
				size += 2 + bs.BinarySize()
			} else {
				size += 2 + 64
			}
		{{end}}
		}
		{{ if or .IsPointer .IsPointerSlice}}
			 SKIP{{.Name}}:
			{{end}}		
	}
	{{end}}
	{{end}}
	return size
}


{{end}}
`